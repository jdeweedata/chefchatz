'use client'

import { useState } from 'react'
import { Button } from '@/components/ui/button'
import { SaveIcon } from 'lucide-react'
import { useToast } from '@/components/ui/use-toast'
import { useAuth } from '@/components/auth/auth-provider'
import { useRouter } from 'next/navigation'
import { supabase } from '@/lib/supabase/client'
import type { Recipe, RecipeInput } from '@/types/recipe'
import { Heart } from 'lucide-react'

interface SaveRecipeButtonProps {
  recipe: Recipe
  onSave?: (recipe: Recipe) => void
}

function parseRecipeText(recipeText: string): Partial<RecipeInput> {
  // Extract title from "Recipe: [Recipe Name]"
  const titleMatch = recipeText.match(/Recipe:\s*([^\n]+)/)
  const title = titleMatch ? titleMatch[1].trim() : 'New Recipe'

  // Extract ingredients between "Ingredients:" and "Instructions:"
  const ingredientsMatch = recipeText.match(/Ingredients:([\s\S]*?)(?=Instructions:)/)
  const ingredients = ingredientsMatch
    ? ingredientsMatch[1]
        .split('\n')
        .map(line => line.trim())
        .filter(line => line.startsWith('-'))
        .map(line => line.substring(1).trim())
    : []

  // Extract instructions between "Instructions:" and "Tips:" (if present)
  const instructionsMatch = recipeText.match(/Instructions:([\s\S]*?)(?=Tips:|$)/)
  const instructions = instructionsMatch
    ? instructionsMatch[1]
        .split('\n')
        .map(line => line.trim())
        .filter(line => /^\d+\./.test(line))
        .map(line => line.replace(/^\d+\.\s*/, ''))
    : []

  // Extract servings from "Servings: [Number]"
  const servingsMatch = recipeText.match(/Servings:\s*(\d+)/)
  const servings = servingsMatch ? parseInt(servingsMatch[1], 10) : 4

  return {
    title,
    description: 'Recipe generated by ChefChatz',
    ingredients,
    instructions,
    servings,
    prep_time: 30,
    cook_time: 30,
    difficulty: 'medium',
    cuisine: 'International',
    tags: [],
  }
}

async function saveRecipeToDatabase(userId: string, recipeData: Partial<RecipeInput>) {
  const { error } = await supabase
    .from('recipes')
    .insert({
      user_id: userId,
      ...recipeData,
    })

  if (error) {
    throw error
  }
}

export function SaveRecipeButton({ recipe, onSave }: SaveRecipeButtonProps) {
  const [isSaving, setIsSaving] = useState(false)
  const [isSaved, setIsSaved] = useState(recipe.is_favorite || false)
  const { user } = useAuth()
  const { toast } = useToast()
  const router = useRouter()

  const handleAuthError = () => {
    toast({
      title: 'Authentication required',
      description: 'Please sign in to save recipes',
      variant: 'destructive',
    })
    router.push('/login')
  }

  const handleSaveSuccess = () => {
    toast({
      title: 'Recipe saved!',
      description: 'The recipe has been saved to your favorites',
    })
  }

  const handleSaveError = (error: Error) => {
    toast({
      title: 'Failed to save recipe',
      description: error.message,
      variant: 'destructive',
    })
  }

  const handleSave = async () => {
    if (!user) {
      handleAuthError()
      return
    }

    try {
      setIsSaving(true)
      const { error } = await supabase
        .from('favorites')
        .upsert({
          user_id: user.id,
          recipe_id: recipe.id,
          created_at: new Date().toISOString(),
        })

      if (error) throw error

      setIsSaved(!isSaved)
      handleSaveSuccess()
      onSave?.(recipe)
    } catch (err) {
      handleSaveError(err instanceof Error ? err : new Error('Failed to save recipe'))
    } finally {
      setIsSaving(false)
    }
  }

  return (
    <Button
      variant="outline"
      className="w-full"
      onClick={handleSave}
      disabled={isSaving}
    >
      <Heart className={isSaved ? 'fill-current' : 'text-current'} />
      <span className="ml-2">{isSaving ? 'Saving...' : 'Save Recipe'}</span>
    </Button>
  )
}
